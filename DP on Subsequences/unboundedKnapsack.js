/**
 * We have infinite supply of items. One item can be picked multiple times. Having a bag weight W, what's
 * the max value can we get if we have an unbounded knapsack.
 *
 * f(n-1, W) -> Till n-1 with bag weigh W, what's the max value you can get.
 *
 * TC -> Not exactly 2^n but exponential definitely
 * SC -> Worst case is O(W) because recursion tree will have W depth if on each step the bag weigh reduces
 * by 1 only
 */

const weight = [2, 4, 6];
const value = [5, 11, 13];
const n = weight.length;
const W = 10;

const unboundedKnapsack = (index, W) => {
  if (index === 0) {
    /**
     * On index 0, i'll only pick the item if its weight is <= W. W / weight[index] will give the number
     * of times i'll need to pick that item & multiplying it with value[index] will return the value that
     * can be generated by picking up that item that many times.
     */
    return (W / weight[index]) * value[index];
  }

  const notTake = unboundedKnapsack(index - 1, W);
  let take = -Infinity;
  if (weight[index] <= W)
    take = value[index] + unboundedKnapsack(index, W - weight[index]);

  return Math.max(notTake, take);
};

const dpArr = new Array(n).fill(-1).map(() => new Array(W + 1).fill(-1));

const unboundedKnapsackDP = (index, W) => {
  if (index === 0) {
    /**
     * On index 0, i'll only pick the item if its weight is <= W. W / weight[index] will give the number
     * of times i'll need to pick that item & multiplying it with value[index] will return the value that
     * can be generated by picking up that item that many times.
     */
    return (W / weight[index]) * value[index];
  }

  if (dpArr[index][W] !== -1) return dpArr[index][W];

  const notTake = unboundedKnapsackDP(index - 1, W);
  let take = -Infinity;
  if (weight[index] <= W)
    take = value[index] + unboundedKnapsackDP(index, W - weight[index]);

  dpArr[index][W] = Math.max(notTake, take);
  return dpArr[index][W];
};

const dpTabulation = new Array(n).fill(-1).map(() => new Array(W + 1).fill(-1));

const unboundedKnapsackTabulation = () => {
  for (let w = 0; w <= W; w++) {
    dpTabulation[0][w] = (w / weight[0]) * value[0];
  }

  for (let i = 1; i <= n - 1; i++) {
    for (let w = 0; w <= W; w++) {
      const notTake = dpTabulation[i - 1][w];
      let take = -Infinity;
      if (weight[i] <= w) take = value[i] + dpTabulation[i][w - weight[i]];
      dpTabulation[i][w] = Math.max(notTake, take);
    }
  }
  return dpTabulation[n - 1][W];
};

console.log(unboundedKnapsack(n - 1, W));
console.log(unboundedKnapsackDP(n - 1, W));
console.log(unboundedKnapsackTabulation());
